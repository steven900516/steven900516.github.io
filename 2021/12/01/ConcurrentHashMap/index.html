<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ConcurrentHashMap | 萌新杀手的博客</title><meta name="keywords" content="JAVA"><meta name="author" content="Steven林"><meta name="copyright" content="Steven林"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ConcurrentHashMap属性&#x2F;&#x2F; 最大容量，同 hashmapprivate static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F; 默认大小  16private static final int DEFAULT_CAPACITY &#x3D; 16;&#x2F;&#x2F; 数组的最大值static final int MAX_ARRAY_SIZE &#x3D; Integ">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentHashMap">
<meta property="og:url" content="https://steven900516.gitee.io/2021/12/01/ConcurrentHashMap/index.html">
<meta property="og:site_name" content="萌新杀手的博客">
<meta property="og:description" content="ConcurrentHashMap属性&#x2F;&#x2F; 最大容量，同 hashmapprivate static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;&#x2F; 默认大小  16private static final int DEFAULT_CAPACITY &#x3D; 16;&#x2F;&#x2F; 数组的最大值static final int MAX_ARRAY_SIZE &#x3D; Integ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg">
<meta property="article:published_time" content="2021-12-01T02:24:47.000Z">
<meta property="article:modified_time" content="2021-12-12T13:39:03.556Z">
<meta property="article:author" content="Steven林">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://steven900516.gitee.io/2021/12/01/ConcurrentHashMap/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ConcurrentHashMap',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-12 21:39:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://imgtu.com/i/fPBsaR" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">萌新杀手的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ConcurrentHashMap</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-01T02:24:47.000Z" title="发表于 2021-12-01 10:24:47">2021-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-12T13:39:03.556Z" title="更新于 2021-12-12 21:39:03">2021-12-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ConcurrentHashMap"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ConcurrentHashMap属性"><a href="#ConcurrentHashMap属性" class="headerlink" title="ConcurrentHashMap属性"></a>ConcurrentHashMap属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大容量，同 hashmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认大小  16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 数组的最大值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 并发等级 ，不可修改   默认 16</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子 0.75</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 转成树链表最大长度 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 转链表的节点数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 最小转换步长 16 常量不可修改 (不太重要)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大  transfer helper 数（当前线程也去迁移的线程数） 默认 2^16-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// 标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>; <span class="comment">// 正在 transfer 的节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; <span class="comment">//  树根的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; <span class="comment">// 不进行序列化的 hash 值</span></span><br><span class="line"><span class="comment">// 可用 cpu 数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 底层的数组 注意是 volatile 的</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"><span class="comment">// 在 resize 的时候使用的数组，只有在 resize 的时候才不是 null  一样volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有竞争的时候使用，或者在初始化的时候作为一个反馈</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeCtl 是一个控制标志</span></span><br><span class="line"><span class="comment">// -1 表示初始化</span></span><br><span class="line"><span class="comment">// -N 表示有 N-1 个线程在 resize</span></span><br><span class="line"><span class="comment">// 正数或0代表hash表还没有被初始化，这个数值表示初始化</span></span><br><span class="line"><span class="comment">// 大于 0 表示下一次进行扩容的时候的阈值</span></span><br><span class="line"><span class="comment">// 它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<p><strong>我们要注意 sizeCtl 属性！在判断状态会使用到</strong></p>
<h1 id="内部类Node"><a href="#内部类Node" class="headerlink" title="内部类Node"></a>内部类Node</h1><p>和 <code>HashMap</code> 一样的。但是注意这个地方采用了 <code>volatile</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;         <span class="comment">//注意是volatile，与HashMap不一致的地方</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K, V&gt; next;    <span class="comment">//注意是volatile，与HashMap不一致的地方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hashcode 比较有意思 HashMap 中使用了 Objects.hashCode(key) ^ Objects.hashCode(value)</span></span><br><span class="line">    <span class="comment">// 但是 Objects 里面还是调用了 key 和 val 的 hashCode 所以原理一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode() ^ val.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然 val 是 volatile 的变量但是不提供修改方法，否则抛异常  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="内部类TreeNode"><a href="#内部类TreeNode" class="headerlink" title="内部类TreeNode"></a>内部类TreeNode</h1><p>直接继承了 <code>Node 节点</code> 所以相比 <code>HashMap</code> 中的 <code>TreeNode</code> 少了 before 和 after 属性。他的方法比较少主要是因为红黑树已经不用这个数据结构了而是采用的 <code>TreeBin</code> ，但是它存在是因为在转成红黑树的时候是先把 <code>Node</code> 封装成 <code>TreeNode</code> 然后再封装到 <code>TreeBin</code> 中的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> final <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K, V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       TreeNode&lt;K, V&gt; left;</span><br><span class="line">       TreeNode&lt;K, V&gt; right;</span><br><span class="line">       TreeNode&lt;K, V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">       boolean red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







<h1 id="内部类TreeBin"><a href="#内部类TreeBin" class="headerlink" title="内部类TreeBin"></a>内部类TreeBin</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作者注释</span></span><br><span class="line"><span class="comment">//TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.</span></span><br><span class="line"><span class="keyword">static</span> final <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K, V&gt; root;  <span class="comment">//用了上文中的 TreeNode</span></span><br><span class="line">       volatile TreeNode&lt;K, V&gt; first;</span><br><span class="line">       volatile Thread waiter;</span><br><span class="line">       volatile int lockState;</span><br><span class="line">       <span class="comment">// values for lockState</span></span><br><span class="line">       <span class="keyword">static</span> final int WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">       <span class="keyword">static</span> final int WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">       <span class="keyword">static</span> final int READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//  大量的 rb-tree 的方法  不分析了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空方法，注释说会创建大小为 16 的数组，估计是延时加载 在 put 里面</span></span><br><span class="line">   <span class="number">1.</span> public ConcurrentHashMap() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了 sizeCtl 就是下一次扩容的容量</span></span><br><span class="line">   <span class="number">2.</span> public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 如果要开的数组比最大的一半还大，那就直接分配最大容量</span></span><br><span class="line">        <span class="comment">// 否则分配 1.5n+1 向上取 2^n</span></span><br><span class="line">        int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 HashMap</span></span><br><span class="line">   <span class="number">3.</span> public ConcurrentHashMap(<span class="built_in">Map</span>&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置容量和负载因子</span></span><br><span class="line">   <span class="number">4.</span> public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0</span>f) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 容量不能小于并发数</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        long size = (long) (<span class="number">1.0</span> + (long) initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long) MAXIMUM_CAPACITY) ?</span><br><span class="line">                MAXIMUM_CAPACITY : tableSizeFor((int) size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><p>get 方法就和 HashMap 差不多，因为发现他连锁都没有加，按照以前的那个套路，首先计算 hash 然后找到数组的节点，看第一个是不是，然后看是否是红黑树或者是链表，它们采用了顺序查找，就 while 循环。</p>
<p>那么我们需要考虑一下为什么不需要加锁，难道我们在读元素的时候同时有别的线程在写不会出现安全问题？举个例子，当我们在遍历一个链表寻找元素的时候刚好有线程在链表的结尾做插入操作，要么我们读到链表结尾的时候，写线程没有更新链表的结尾元素那么我们就认为读先于写也就没有安全问题，因为我们在读的时候不会发现尾节点指针正好发生变化，简单来说写线程的节点指针操作是原子的，对其他线程也是可见的，这时你应该清楚为什么链表的 <code>next</code> 是 <code>volatile</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public V get(<span class="built_in">Object</span> key) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line">        Node&lt;K, V&gt; e, p;</span><br><span class="line">        int n, eh;</span><br><span class="line">        K ek;</span><br><span class="line">        int h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断头结点是不是</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            <span class="comment">// 红黑树查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 顺序查找</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="put-putVal-方法"><a href="#put-putVal-方法" class="headerlink" title="put()/putVal()方法"></a>put()/putVal()方法</h2><p>最重要的，put 方法。这个方法里面直接调用了 putVal ，其实 putVal 的逻辑有点复杂，就单看代码来说，代码量还是比较大的。    那么我们先介绍一下 putVal 的大概的逻辑然后再看代码。</p>
<ol>
<li>首先就判断了 key 和 value 不能为空的情况，一开始觉得还挺奇怪的 HashMap 就允许 null 作为键值为什么 ConcurrentHashMap 却不行，这里我查了一下这段源码作者 Doug Lea 的解释是 “ 在普通的非并发的 HashMap 中我们可以存放 null 然后至于这个地方是否是真的为 null 还是由于键不存在呢，我们可以采用 <code>containsKey</code> 来判断。但是在并发情况下在调用方法时可能会发生引用关系的变化导致歧义 ”。感觉还是有点抽象难懂，我自己的理解就是：当我们调用 <code>map.get(key)</code> 时候返回 <code>null</code> 的时候假如根本不存在这个 <code>key</code> ，但是我们由于不清楚这个地方的值到底是 <code>null</code> 还是这个 <code>key</code> 根本不存在，我们就会调用 <code>containsKey</code> 来检查，但是在这个时间间隙中有其他线程往里面放了一个 <code>key -&gt; null</code> 导致我们检测的结果是有这个键值对，从而误判！ </li>
<li>然后我们前面也提到了，在构造方法中没有任何初始化表的操作，所以说我们在 putVal 中如果判断到表空，就需要进行初始化工作。这个初始化调用了一个 <code>initTable()</code> 这个方法稍后专门分析。 </li>
<li>接着就是利用 hash 值来获取数组的索引了，首先还是判断那个对应的位置有没有元素，如果没有的话就简单了，采用 CAS 操作添加一个新节点此时添加工作就完成了可以返回了。如果不是这种情况就继续往下看。 </li>
<li>我们看头结点的 Hash 值是否是 <code>MOVED</code> ，如果是就说明当前的表正在进行 <code>transfer</code> 我们就让当前线程去帮助 <code>transfer</code> 。现在没看懂没关系等看到 <code>transfer</code> 方法的时候就知道为什么了。 </li>
<li>否则的话就是一个正常的链表或者红黑树了，这时候我们就和 HashMap 一样，如果是一个链表我们就遍历链表，然后遇到相同的 key 进行 value 的替换，否则插入到链表的结尾。 如果是一个红黑树就执行红黑树的插入操作。 注意这个操作是在同步代码块中进行的，因为我们不能保证多线程的修改安全，但是这个代码块的锁是头结点，也就是数组有多少元素我们就可以同时操作多少把锁，这样并发数就是数组的长度。而前面定义的并发数没有实质的作用。 </li>
<li>最后由于我们插入了一个节点需要判断一下当前的节点数是不是大于转红黑树的阈值(默认为8)。是则调用 <code>treeifyBin</code> ，这个方法也比较复杂，待会专门来说。 </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">// 不允许 null 键值 解释是在我们没办法判断是没有对应的值还是值为 null 。</span></span><br><span class="line">    <span class="comment">// 在非并发的情况下我们可以使用 containsKey/Value(null) 来明确知道 是不是有 null key/val</span></span><br><span class="line">    <span class="comment">// 这也就解释了为什么 hashmap 在查找的时候采用了先使用 null 来查找的策略</span></span><br><span class="line">    <span class="comment">// 但是并发的话，他底层调用了 get 方法，而 get 方法不是同步的，有可能会发生改变产生歧义</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    int hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        int n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组为 null 也就是没有初始化(延时加载)或者数组没有元素，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空， 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到方法的最后面了</span></span><br><span class="line">            <span class="comment">// 如果 CAS 成功，那就是没有并发操作 方法可以结束了  有并发操作就进行下一次循环，注意外面的循环是死循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空  也就是一般情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                <span class="comment">// 判断是否有新的节点插入到头部，或者删除头部节点造成不匹配  进行下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于等于 0，说明是链表</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了&quot;相等&quot;的 key，直接覆盖他的 value ，方法结束</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出链表/红黑树的操作  的同步代码块</span></span><br><span class="line">            <span class="comment">// binCount != 0 说明上面在做链表操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">// 具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable()方法"></a>initTable()方法</h2><p>上面已经分析了关于 put 方法，我们还有两个问题没有解决，一个是初始化表，另外一个是转成红黑树，先分析表的初始化。那先回顾一下 HashMap 他是采用同样的延时加载然后在 <code>resize</code> 方法中进行了表的初始化工作。也就是 HashMap 的 <code>resize</code> 方法同时进行了初始化和扩容以及迁移的工作，在 ConcurrentHashMap 中划分的更细致，初始化就只进行初始化，因为他是并发的要考虑到更多。   一样的，我们先分析一下大致的思路。</p>
<ol>
<li>首选先需要看是不是有别的线程在进行初始化，如果是我们就不要进行初始化了让出 cpu 资源让别的线程继续初始化。这个如何判断别的线程是否在初始化？就涉及到了前面的 <code>sizeCtl</code> 属性，当他是 -1 的时候就说明在进行表的初始化工作。 </li>
<li>显然当别的线程没有初始化，当前线程就要初始化。并且不让别的线程进行争夺，就把 <code>sizeCtl</code> 用 CAS 置为 -1，并开始初始化。 </li>
<li>初始化的工作有两个，一是 new 一个容量为 16 的新数组，其次设置扩容的阈值也就是 <code>sizeCtl</code> 的值，设置好了也说明初始化完毕。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 别的线程已经初始化好了或者正在初始化 sizeCtl 为 -1</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// 让出线程的执行权，运行态转就绪态</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁 基本在这就相当于同步代码块</span></span><br><span class="line">        <span class="comment">//将 sizeCtl 设置为 -1  !!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的  他的写发生在别人的读之前</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置下次扩容的时候的阈值,,,,,重要！！！</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="treeifyBin-方法"><a href="#treeifyBin-方法" class="headerlink" title="treeifyBin()方法"></a>treeifyBin()方法</h2><p>接下来就要看看链表转红黑树的操作了。</p>
<p>这个操作没有像我想的那样直接进行转树的操作，而是做了一系列的判断。    </p>
<p>当链表长度大于等于 16  但数组长度小于 64 时，需要进行一次扩容操作，扩容操作又委托给了 <code>tryPresize</code> 扩容是预计扩容到原来的两倍。注意区分链表长度和数组长度不要弄混了！！！    </p>
<p>接下来就是真正的链表转成树的操作了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private final <span class="keyword">void</span> treeifyBin(Node&lt;K, V&gt;[] tab, int index) &#123;</span><br><span class="line">        Node&lt;K, V&gt; b;</span><br><span class="line">        int n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">            <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">// 扩容操作 大小扩容为 (3*n+1)--&gt; 2^n</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// b 是头结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                synchronized (b) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                        TreeNode&lt;K, V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K, V&gt; p =</span><br><span class="line">                                    <span class="keyword">new</span> TreeNode&lt;K, V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                            <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K, V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="tryPresize-方法"><a href="#tryPresize-方法" class="headerlink" title="tryPresize()方法"></a>tryPresize()方法</h2><p>继续分析上面遗留下来的问题，扩容操作。</p>
<ol>
<li>首先判断表是否为空，空则进行初始化，代码同 <code>initTable</code>  </li>
<li>如果 <code>3*tableSize+1 &lt; 扩容阈值</code> 就不扩容，这个情况基本不会发生。 </li>
<li>将 <code>sizeCtl</code> 设置为下次要进行扩容的阈值，然后进行 <code>transfer</code> ，这个方法里面才是真正的将数组大小扩充为原来的两倍并且进行数据迁移。 </li>
</ol>
<p>    整体看起来还是以前的 HashMap 的套路，他的 <code>resize</code> 进行初始化、扩容、数据迁移。而这里把这三步拆成了三个方法分别来做，以保证高并发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private final <span class="keyword">void</span> tryPresize(int size) &#123;</span><br><span class="line">        <span class="comment">// c：size*1.5+1 ，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">        int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        int sc;</span><br><span class="line">        <span class="comment">// sizeCtl &gt; 0 表示下次扩容的阈值</span></span><br><span class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K, V&gt;[] tab = table;</span><br><span class="line">            int n;</span><br><span class="line">            <span class="comment">// 数组初始化</span></span><br><span class="line">            <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                n = (sc &gt; c) ? sc : c;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, <span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                            @SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">                            Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line">                            table = nt;</span><br><span class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        sizeCtl = sc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 如果扩容后的值还小于等于阈值或者，当前数组长度已经达到最大了 不进行扩容</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 进行扩容操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">                int rs = resizeStamp(n);</span><br><span class="line">                <span class="comment">// 不可能发生</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Node&lt;K, V&gt;[] nt;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||</span><br><span class="line">                            sc == rs + <span class="number">1</span> ||</span><br><span class="line">                            sc == rs + MAX_RESIZERS ||</span><br><span class="line">                            (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                            transferIndex &lt;= <span class="number">0</span></span><br><span class="line">                            )</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 1. 将 SIZECTL 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2  这个值等于</span></span><br><span class="line">                <span class="comment">//  (n的32位二进制中空位数 &lt;&lt; 16 ) + 2 肯定是正数 也就是下次扩容的阈值</span></span><br><span class="line">                <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 这个 cas 操作保证了只有一个线程会最先进行 transfer 操作</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h2 id="transfer-方法"><a href="#transfer-方法" class="headerlink" title="transfer()方法"></a>transfer()方法</h2><p><code>transfer</code> 是这个类中最麻烦也是最精巧的一个方法，还是先说思路再阅读代码。</p>
<ol>
<li>如果当前的 <code>nextTab</code> 是空，也就是说需要进行扩容的数组还没有初始化，那么初始化一个大小是原来两倍的数组出来，作为扩容后的新数组。 </li>
<li>我们分配几个变量，来把原来的数组拆分成几个完全相同的段，你可以把他们想象成一个个大小相同的短数组，每个短数组的长度是 <code>stride</code> 。 </li>
<li>我们先取最后一个短数组，用 <code>i</code> 表示一个可变的指针，可指向短数组的任意一个位置，最开始指向的是短数组的结尾。<code>bound</code> 表示短数组的下界，也就是开始的位置。也就是我们在短数组选择的时候是采用从后往前进行的。 （<strong>从后往前</strong>！！！）</li>
<li>然后使用了一个全局的属性 <code>transferIndex</code>（线程共享），来记录当前已经选择过的短数组和还没有被选择的短数组之间的分隔。 </li>
<li>那么当前的线程选择的这个短数组其实就是当前线程应该进行的数据迁移任务，也就是说当前线程就负责完成这一个小数组的迁移任务就行了。那么很显然在 <code>transferIndex</code> 之前的，没有被线程处理过的短数组就需要其他线程来帮忙进行数据迁移，其他线程来的时候看到的是 <code>transferIndex</code> 那么他们就会从 <code>transferIndex</code> 往前数 <code>stride</code> 个元素作为一个小数组当做自己的迁移任务。 </li>
</ol>
<p>    好，现在可能感觉有点乱，来总结一下。当前的数组的迁移被分为很多的任务包，每一个任务包中有 <code>stride</code> 个元素，然后这些任务包需要被从后往前的分配给不同的线程。分配过程依赖于共享的全局变量 <code>transferIndex</code> 。这样做的原因就是为了高并发，不得不佩服写这个类源码的大师！ 下面用一张图在来总结一下上面所说的内容。</p>
<p><img src="https://i.loli.net/2021/11/30/652biLWCORYEa1X.png" alt="image.png"></p>
<p>现在线程收到自己的任务包了，肯定就需要进行数据迁移的工作了。迁移工作就比较简单了，由于是需要对链表或红黑树节点进行操作，必须要对过程同步，锁还是头结点。进行节点迁移的时候，就是和 HashMap 一样，把原来的链表和树拆成两部分，分别放到 i 和 i+n （相同位置）上。    </p>
<p>我们还是主要看链表的拆分，采用的看 hash 值的某一特定位是 0 还是 1 来决定放在哪个位置，节点采用的头插法，也就是部分的节点的顺序是反的。为什么说部分是反的？那是因为他在里面一大段代码都在干一件事，去找原链表的最后一段特定位相同的完整序列保持顺序不变。这个比较难说清楚还是用一张图来说明一下。</p>
<p><img src="https://i.loli.net/2021/11/30/t5Ma9eKTuz2ELA6.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/11/30/D2OiWvNE1GBuPnI.png" alt="image.png"></p>
<p>ForwardingNode</p>
<p><img src="https://i.loli.net/2021/11/30/nwNOcivPrmD6E9s.png" alt="image.png"></p>
<p>接下来贴源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 把节点拷贝到新数组里面</span><br><span class="line">    <span class="comment">// 调用情况： 1.在 put 中的转红黑树的时候，如果大小不足 64 试着扩容 时候调用了 transfer</span></span><br><span class="line">    <span class="comment">//           2.在调用 put 完成以后，有一个 addCount 操作里面也调用了 transfer</span></span><br><span class="line">    <span class="comment">//           3.helpTransfer 中</span></span><br><span class="line">    private final <span class="keyword">void</span> transfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab) &#123;</span><br><span class="line">        int n = tab.length, stride;</span><br><span class="line">        <span class="comment">// 将这些节点分成若干个任务迁移，每一个任务里面的节点数就是 stride</span></span><br><span class="line">        <span class="comment">// 所以当只有一个 cpu 的时候就是一个任务，多个 cpu 按下面的规则</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nextTab 为 null，先进行一次初始化，在属性字段里面我们就看到了这个字段是只有在迁移的时候不是 null</span></span><br><span class="line">        <span class="comment">// 其他时间都是 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于前面的 cas 操作已经保证了只有一个线程进行 transfer 所以不担心每个线程都会 new 出自己的新数组</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 容量翻倍，所以说前面那个 tryPresize 方法里面计算的希望要扩容的大小只是为了与阈值比较一下</span></span><br><span class="line">                <span class="comment">// 真正在扩容的时候只扩充为原来的 2 倍</span></span><br><span class="line">                Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// volatile 赋值</span></span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            <span class="comment">// 用于控制迁移的位置</span></span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新数组长度</span></span><br><span class="line">        int nextn = nextTab.length;</span><br><span class="line">        <span class="comment">// 标志节点</span></span><br><span class="line">        <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">        <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">        <span class="comment">// 就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">        ForwardingNode&lt;K, V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K, V&gt;(nextTab);</span><br><span class="line">        <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">        boolean advance = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 在对 nextTable 赋值后记得清理节点  待会说</span></span><br><span class="line">        boolean finishing = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>, bound = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">            Node&lt;K, V&gt; f;</span><br><span class="line">            int fh;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说了这么多 很多都是废话，其实就一句话就是：我们从数组的结尾开始把元素分成任务，其中每一个任务的节点数就是 stride</span></span><br><span class="line">            <span class="comment">// 任务是从后往前分配的，也就是最先分出去的是数组结尾的那一段。任务开始的元素下标是 i 结束的下标是 bound 注意 bound &lt; i</span></span><br><span class="line">            <span class="comment">// 因为是从后往前来的</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                int nextIndex, nextBound;</span><br><span class="line">                <span class="comment">// 刚领取的任务完成了 也就是 i&gt;=bound  一开始我找了半天的 --i 竟然藏在这里</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 任务领完了 transferIndex 本来是数组的长度，现在都成0 了说明任务都分派完了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = <span class="number">-1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 实施任务分派，更新了 TRANSFERINDEX 其他线程能看到</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主要就是判断 i&lt;0 ， 也就是是不是都迁移完了  至于 i&gt;=n 是 i = n 导致的</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                int sc;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl = 1.5*n 下次的阈值 结束迁移方法</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 之前我们说过，SIZECTL 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">                <span class="comment">// d但是怎么会出现这种情况？？？？？</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 到这里，说明 (sizeCtl - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                    <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果原数组 i 处是空的，没有任何节点，那么放入 ForwardingNode 作为标志</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="comment">// 原数组处有值</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">                <span class="comment">// 迁移干的事同样的事 就是把链表拆成两部分，树也分裂成两部分  和 HashMap 真的几乎一样</span></span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    <span class="comment">// 重复判断防止多线程修改</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K, V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            int runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">// p.hash &amp; n 其实是取某一特定的位，只能是 0/1 所以这个做法是把原来一个链表分成两个</span></span><br><span class="line">                            <span class="comment">// lastRun 指向最后一段 runBit 相同的连续的节点的开始</span></span><br><span class="line">                            <span class="comment">// 感觉这一段代码写得有点蠢，就是为了找到最后一段完整的同类型的节点遍历了整个链表 ？ 还是我理解错了？</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                int b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 分链表的准备工作</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 最后还是按照那个特定的位是 0/1 分成两个链表</span></span><br><span class="line">                            <span class="comment">// 链表的顺序翻转了，采用的头插</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                int ph = p.hash;</span><br><span class="line">                                K pk = p.key;</span><br><span class="line">                                V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 链表放在新数组的位置 i 和 i+n</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                            <span class="comment">// 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                            TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                            TreeNode&lt;K, V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K, V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            int lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K, V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                int h = e.hash;</span><br><span class="line">                                TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> TreeNode&lt;K, V&gt;</span><br><span class="line">                                        (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(hi) : t;</span><br><span class="line">                            <span class="comment">// 处理同链表</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<h2 id="helpTransfer-方法"><a href="#helpTransfer-方法" class="headerlink" title="helpTransfer()方法"></a>helpTransfer()方法</h2><p>这个方法主要是让其他线程在对表做操作的时候刚好遇到了，表在扩容，数据迁移。就让这些线程帮助完成这个数据迁移，也就是去领取 <code>transfer</code> 中的数据迁移的任务包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. putVal 当有 MOVED 节点的时候  2.replaceNode 也就是在 remove 中 当有 MOVED 节点的时候</span></span><br><span class="line">    <span class="comment">//3. clear 4.conpute/IfPresent 干嘛的？ 5.merge 干嘛的？</span></span><br><span class="line">    <span class="comment">// 好了发现规律了就是当我们在有遍历节点的操作的时候遇到了 MOVED 就去 helpTransfer 也就是 transfer</span></span><br><span class="line">    final Node&lt;K, V&gt;[] helpTransfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt; f) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] nextTab;</span><br><span class="line">        int sc;</span><br><span class="line">        <span class="comment">// 条件判断 + 把正在 transfer 的 nextTab 赋值给 nextTab</span></span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K, V&gt;) f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">            int rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="comment">// 当 transfer 还没有结束  sizeCtl &lt; 0 表示在迁移</span></span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 把 SIZECTL 加一 然后 transfer</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>首先这个类很多操作和 <code>HashMap</code> 是类似的，但是麻烦就麻烦在 <code>锁分离技术</code> 和 <code>并发处理</code> </p>
</li>
<li><p>底层还是采用的 <code>数组</code> + <code>链表</code> + <code>红黑树</code> 来实现的，但是红黑树的 <code>TreeNode</code> 改成了 <code>TreeBin</code></p>
</li>
<li><p>里面有很多 CAS （Compare And Swap）操作，比如说 <code>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</code>意思是如果 <code>valueOffset</code> 位置包含的值与 <code>expect</code> 值相同，则更新 <code>valueOffset</code> 位置的值为update，并返回true，否则不更新，返回false。</p>
</li>
<li><p>不仅仅是 CAS 还有一些重量级的锁。也就是 <code>synchronized代码块</code> 用来保证操作同一数组元素下的节点的一致性，后面会看到。 </p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Steven林</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://steven900516.gitee.io/2021/12/01/ConcurrentHashMap/">https://steven900516.gitee.io/2021/12/01/ConcurrentHashMap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://steven900516.gitee.io" target="_blank">萌新杀手的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"><img class="prev-cover" src="https://pic4.zhimg.com/v2-af1fefc4f2f5b99b79787b57756e6ea4_r.jpg?source=1940ef5c" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">缓存击穿，缓存穿透，缓存雪崩</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">类加载完整流程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/26/类加载完整流程/" title="类加载完整流程"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">类加载完整流程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://imgtu.com/i/fPBsaR" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Steven林</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/steven900516" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap%E5%B1%9E%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">ConcurrentHashMap属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BBNode"><span class="toc-number">2.</span> <span class="toc-text">内部类Node</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BBTreeNode"><span class="toc-number">3.</span> <span class="toc-text">内部类TreeNode</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BBTreeBin"><span class="toc-number">4.</span> <span class="toc-text">内部类TreeBin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">get()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-putVal-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">put()&#x2F;putVal()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initTable-%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">initTable()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeifyBin-%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">treeifyBin()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tryPresize-%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">tryPresize()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transfer-%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.</span> <span class="toc-text">transfer()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#helpTransfer-%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">helpTransfer()方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/19/1%E5%B0%8F%E6%97%B6%E5%86%85%E7%82%B9%E8%B5%9E5%E6%AC%A1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%BE%E8%AE%A1%EF%BC%88Java%E5%8F%AF%E6%8B%93%E5%B1%95%E5%88%B0Redis%EF%BC%89/" title="1小时内点赞5次滑动窗口设计（Java可拓展到Redis）"><img src="https://th.bing.com/th/id/R.2ed30f03ac15f764ae2bad6915bc57eb?rik=PXhw%2fywdtuYFuQ&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1小时内点赞5次滑动窗口设计（Java可拓展到Redis）"/></a><div class="content"><a class="title" href="/2022/01/19/1%E5%B0%8F%E6%97%B6%E5%86%85%E7%82%B9%E8%B5%9E5%E6%AC%A1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%AE%BE%E8%AE%A1%EF%BC%88Java%E5%8F%AF%E6%8B%93%E5%B1%95%E5%88%B0Redis%EF%BC%89/" title="1小时内点赞5次滑动窗口设计（Java可拓展到Redis）">1小时内点赞5次滑动窗口设计（Java可拓展到Redis）</a><time datetime="2022-01-19T09:37:03.000Z" title="发表于 2022-01-19 17:37:03">2022-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="缓存击穿，缓存穿透，缓存雪崩"><img src="https://pic4.zhimg.com/v2-af1fefc4f2f5b99b79787b57756e6ea4_r.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存击穿，缓存穿透，缓存雪崩"/></a><div class="content"><a class="title" href="/2021/12/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="缓存击穿，缓存穿透，缓存雪崩">缓存击穿，缓存穿透，缓存雪崩</a><time datetime="2021-12-12T13:37:47.000Z" title="发表于 2021-12-12 21:37:47">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/ConcurrentHashMap/" title="ConcurrentHashMap"><img src="https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap"/></a><div class="content"><a class="title" href="/2021/12/01/ConcurrentHashMap/" title="ConcurrentHashMap">ConcurrentHashMap</a><time datetime="2021-12-01T02:24:47.000Z" title="发表于 2021-12-01 10:24:47">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/" title="类加载完整流程"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类加载完整流程"/></a><div class="content"><a class="title" href="/2021/11/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/" title="类加载完整流程">类加载完整流程</a><time datetime="2021-11-26T03:04:27.000Z" title="发表于 2021-11-26 11:04:27">2021-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/ThreadPoolExecutor/" title="ThreadPoolExecutor"><img src="https://ts1.cn.mm.bing.net/th?id=OIP-C.q6QaR2zyDxrl_OSMcxhv9gHaEo&amp;w=176&amp;h=170&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ThreadPoolExecutor"/></a><div class="content"><a class="title" href="/2021/11/17/ThreadPoolExecutor/" title="ThreadPoolExecutor">ThreadPoolExecutor</a><time datetime="2021-11-17T08:27:47.000Z" title="发表于 2021-11-17 16:27:47">2021-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Steven林</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>