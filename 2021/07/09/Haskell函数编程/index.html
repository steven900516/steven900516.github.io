<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Haskell函数编程 | 萌新杀手的博客</title><meta name="keywords" content="Haskell"><meta name="author" content="Steven林"><meta name="copyright" content="Steven林"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介haskell 是一门纯函数式编程语言。 在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你给变量 a 赋值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程，你就可以重复执行操作。然而在函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某数间所有数字的乘积”。变量一">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell函数编程">
<meta property="og:url" content="https://steven900516.gitee.io/2021/07/09/Haskell%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="萌新杀手的博客">
<meta property="og:description" content="简介haskell 是一门纯函数式编程语言。 在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你给变量 a 赋值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程，你就可以重复执行操作。然而在函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“阶乘是指从1到某数间所有数字的乘积”。变量一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3093977134,1475813689&fm=26&gp=0.jpg">
<meta property="article:published_time" content="2021-07-09T14:51:53.000Z">
<meta property="article:modified_time" content="2021-07-10T06:45:28.683Z">
<meta property="article:author" content="Steven林">
<meta property="article:tag" content="Haskell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3093977134,1475813689&fm=26&gp=0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://steven900516.gitee.io/2021/07/09/Haskell%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Haskell函数编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-10 14:45:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://imgtu.com/i/fPBsaR" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3093977134,1475813689&amp;fm=26&amp;gp=0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">萌新杀手的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Haskell函数编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-09T14:51:53.000Z" title="发表于 2021-07-09 22:51:53">2021-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-10T06:45:28.683Z" title="更新于 2021-07-10 14:45:28">2021-07-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Haskell函数编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>haskell 是一门<strong>纯函数式编程语言</strong>。</p>
<p>在命令式语言中执行操作需要给电脑安排一组命令，随着命令的执行，状态就会随之发生改变。例如你给变量 a 赋值为 5，而随后做了其它一些事情之后 a 就可能变成的其它值。有控制流程，你就可以重复执行操作。然而在函数式编程语言中，你不是像命令式语言那样命令电脑“要做什么”，而是通过用函数来描述出问题“是什么”，如“<em>阶乘是指从1到某数间所有数字的乘积</em>”。变量一旦赋值，就不可以更改了，你已经说了 a 就是 5，就不能再另说 a 是别的什么数。做人不能食言，对不？所以说，函数式编程语言中的函数能做的唯一事情就是求值，因而没有副作用。一开始会觉得这很受限，不过好处也正源于此：若以同样的参数调用同一函数两次，得到的结果总是相同。这被称作“<em>引用透明</em>”。如此一来编译器就可以理解程序的行为，你也很容易就能验证一个函数的正确性，继而可以将一些简单的函数组合成更复杂的函数。</p>
<hr>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p><strong>Haskell 是 Static Type</strong>—&gt;编译时期每个表达式的型别都已经确定下来</p>
<h2 id="各种类型（使用-t进行查看-）"><a href="#各种类型（使用-t进行查看-）" class="headerlink" title="各种类型（使用:t进行查看 ）"></a>各种类型（使用:t进行查看 ）</h2><p>与 Java 和 Pascal 不同，Haskell 支持型别推导。写下一个数字，你就没必要另告诉 Haskell 说”它是个数字”，它自己能推导出来。这样我们就不必在每个函数或表达式上都标明其型别了。</p>
<p>(配置好环境后在命令行中输入<em>ghci</em>)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t &#x27;a&#x27;  </span><br><span class="line">&#x27;a&#x27; :: <span class="type">Char</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span>  </span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">&quot;HELLO!&quot;</span>  </span><br><span class="line"><span class="string">&quot;HELLO!&quot;</span> :: [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, &#x27;a&#x27;)  </span><br><span class="line">(<span class="type">True</span>, &#x27;a&#x27;) :: (<span class="type">Bool</span>, <span class="type">Char</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">4</span> == <span class="number">5</span>  </span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>







<p><code>:t</code> 命令处理一个表达式的输出结果为表达式后跟 <code>::</code> 及其型别，<code>::</code> 读作”它的型别为”。凡是明确的型别，其首字母必为大写。<code>&#39;a&#39;</code>, 如它的样子，是 <code>Char</code> 型别，易知是个字元 (character)。<code>True</code> 是 <code>Bool</code> 型别，也靠谱。不过这又是啥，检测 <code>&quot;hello&quot;</code> 得一个 <code>[Char]</code> 这方括号表示一个 List，所以我们可以将其读作”一组字元的 List”。而与 List 不同，每个 Tuple 都是独立的型别，于是 <code>(True,&#39;a&#39;)</code> 的型别是 <code>(Bool,Char)</code>，而 <code>(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</code> 的型别为 <code>(Char,Char,Char)</code>。<code>4==5</code> 一定回传 <code>False</code>，所以它的型别为 Bool</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数也有型别。编写函数时，给它一个明确的型别声明是个好习惯，下面通过举例子来进行讲解</p>
<p>例如以下函数</p>
<ul>
<li>查找是否有大写字母</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]] </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzU9vd"><img src="https://z3.ax1x.com/2021/07/10/RzU9vd.png" alt="RzU9vd.png" style="zoom:150%;" /></a></p>
<p><code>removeNonUppercase</code> 的型别为 <code>[Char]-&gt;[Char]</code>，从它的参数和回传值的型别上可以看出，它将一个字串映射为另一个字串。<code>[Char]</code> 与 <code>String</code> 是等价的，但使用 <code>String</code> 会更清晰：<code>removeNonUppercase :: String -&gt; String</code>。编译器会自动检测出它的型别，我们还是标明了它的型别声明。</p>
<ul>
<li>三个整数相加（多参数）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzUV58"><img src="https://z3.ax1x.com/2021/07/10/RzUV58.png" alt="RzUV58.png"></a></p>
<p>参数之间由 <code>-&gt;</code> 分隔，而与回传值之间并无特殊差异。回传值是最后一项，参数就是前三项。稍后，我们将讲解为何只用 <code>-&gt;</code> 而不是 <code>Int,Int,Int-&gt;Int</code> 之类”更好看”的方式来分隔参数。</p>
<p>如果你打算给你编写的函数加上个型别声明却拿不准它的型别是啥，只要先不写型别声明，把函数体写出来，再使用 <code>:t</code> 命令测一下即可。函数也是表达式，所以 <code>:t</code> 对函数也是同样可用的。</p>
<ul>
<li>阶乘</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span>  </span><br><span class="line"><span class="title">factorial</span> n = product [<span class="number">1.</span>.n]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzUDVx"><img src="https://z3.ax1x.com/2021/07/10/RzUDVx.png" alt="RzUDVx.png"></a></p>
<p>product为Haskell自带函数，及阶乘，后面可用递归来进行实现</p>
<p><strong>Int</strong> 表示整数。7 可以是 Int，但 7.2 不可以。Int 是有界的，也就是说它由上限和下限。对 32 位的机器而言，上限一般是 <code>2147483647</code>，下限是 <code>-2147483648</code>。</p>
<p><strong>Integer</strong> 表示…厄…也是整数，但它是无界的。这就意味着可以用它存放非常非常大的数，我是说非常大。它的效率不如 Int 高。</p>
<h2 id="Haskell自带函数型别"><a href="#Haskell自带函数型别" class="headerlink" title="Haskell自带函数型别"></a>Haskell自带函数型别</h2><p>你觉得 <code>head</code> 函数的型别是啥？它可以取任意型别的 List 的首项，是怎么做到的呢？我们查一下！（使用：t）</p>
<ul>
<li><strong>head</strong></li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t head  </span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a  </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzUHJS"><img src="https://z3.ax1x.com/2021/07/10/RzUHJS.png" alt="RzUHJS.png"></a></p>
<p>嗯! <code>a</code> 是啥？型别吗？想想我们在前面说过，凡是型别其首字母必大写，所以它不会是个型别。它是个型别变数，意味着 a 可以是任意的型别。这一点与其他语言中的泛型 (generic) 很相似，但在 Haskell 中要更为强大。它可以让我们轻而易举地写出型别无关的函数。使用到型别变数的函数被称作”多态函数 “，<code>head</code> 函数的型别声明里标明了它可以取任意型别的 List 并回传其中的第一个元素。在命名上，型别变数使用多个字元是合法的，不过约定俗成，通常都是使用单个字元</p>
<ul>
<li><p><strong>fst</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fst  </span><br><span class="line"><span class="title">fst</span> :: (a, b) -&gt; a  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzUqzQ"><img src="https://z3.ax1x.com/2021/07/10/RzUqzQ.png" alt="RzUqzQ.png"></a></p>
<p>可以看到<code>fst</code>取一个包含两个型别的 Tuple 作参数，并以第一个项的型别作为回传值。这便是 <code>fst</code> 可以处理一个含有两种型别项的 pair 的原因。注意，<code>a</code> 和 <code>b</code> 是不同的型别变数，但它们不一定非得是不同的型别，它只是标明了首项的型别与回传值的型别相同。</p>
<ul>
<li><strong>Eq</strong></li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (==)  </span><br><span class="line">(==) :: (<span class="type">Eq</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> == <span class="number">5</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> /= <span class="number">5</span>   </span><br><span class="line"><span class="type">False</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; == &#x27;a&#x27;   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Ho Ho&quot;</span> == <span class="string">&quot;Ho Ho&quot;</span>   </span><br><span class="line"><span class="type">True</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">3.432</span> == <span class="number">3.432</span>   </span><br><span class="line"><span class="type">True</span> </span><br></pre></td></tr></table></figure>



<p>有意思。在这里我们见到个新东西：<code>=&gt;</code> 符号。它左边的部分叫做型别约束。我们可以这样阅读这段型别声明：”相等函数取两个相同型别的值作为参数并回传一个布林值，而这两个参数的型别同在 Eq 类之中(即型别约束)”</p>
<p><strong>Eq</strong> 这一 Typeclass 提供了判断相等性的介面，凡是可比较相等性的型别必属于 <code>Eq</code> class。</p>
<p><code>elem</code> 函数的型别为: <code>(Eq a)=&gt;a-&gt;[a]-&gt;Bool</code>。这是它在检测值是否存在于一个 List 时使用到了==的缘故。</p>
<ul>
<li><strong>Ord</strong>（排序属性）</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (&gt;)  </span><br><span class="line">(&gt;) :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Abrakadabra&quot;</span> &lt; <span class="string">&quot;Zebra&quot;</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">&quot;Abrakadabra&quot;</span> `compare` <span class="string">&quot;Zebra&quot;</span>  </span><br><span class="line"><span class="type">LT</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> &gt;= <span class="number">2</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> `compare` <span class="number">3</span>  </span><br><span class="line"><span class="type">GT</span>  </span><br></pre></td></tr></table></figure>

<p>型别若要成为Ord的成员，必先加入Eq家族。</p>
<p>Ord 包含可比较大小的型别。除了函数以外，我们目前所谈到的所有型别都属于 <code>Ord</code> 类。<code>Ord</code> 包中包含了<code>&lt;, &gt;, &lt;=, &gt;=</code> 之类用于比较大小的函数。<code>compare</code> 函数取两个 <code>Ord</code> 类中的相同型别的值作参数，回传比较的结果。这个结果是如下三种型别之一：<code>GT, LT, EQ</code>。</p>
<p>剩下的可以自己进行:t 查询返回结果   (Show，Enum，Bounded……）</p>
<h1 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h1><h2 id="模式匹配-Pattern-matching"><a href="#模式匹配-Pattern-matching" class="headerlink" title="模式匹配 (Pattern matching)"></a>模式匹配 (Pattern matching)</h2><p>本章讲的就是 Haskell 那套独特的语法结构，先从模式匹配开始。模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据。</p>
<p>在定义函数时，你可以为不同的模式分别定义函数本身，这就让程式码更加简洁易读。你可以匹配一切数据型别 — 数字，字元，List，元组，等等。我们弄个简单函数，让它检查我们传给它的数字是不是 7。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">&quot;LUCKY NUMBER SEVEN!&quot;</span>  </span><br><span class="line"><span class="title">lucky</span> x = <span class="string">&quot;Sorry, you&#x27;re out of luck, pal!&quot;</span>   </span><br></pre></td></tr></table></figure>

<p>在呼叫 <code>lucky</code> 时，模式会从上至下进行检查，一旦有匹配，那对应的函数体就被应用了。这个模式中的唯一匹配是参数为 7，如果不是 7，就转到下一个模式，它匹配一切数值并将其绑定为 <code>x</code> 。这个函数完全可以使用 <code>if</code> 实现，不过我们若要个分辨 1 到 5 中的数字，而无视其它数的函数该怎么办？要是没有模式匹配的话，那可得好大一棵 <code>if-else</code> 树了！</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">&quot;One!&quot;</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">&quot;Two!&quot;</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">&quot;Three!&quot;</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">&quot;Four!&quot;</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">&quot;Five!&quot;</span>  </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">&quot;Not between 1 and 5&quot;</span>  </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RzdG3F"><img src="https://z3.ax1x.com/2021/07/10/RzdG3F.png" alt="RzdG3F.png" style="zoom:150%;" /></a></p>
<p><strong>阶乘函数</strong> 递归实现</p>
<p>记得前面实现的那个阶乘函数么？当时是把 <code>n</code> 的阶乘定义成了 <code>product [1..n]</code>。也可以写出像数学那样的递回实现，先说明 0 的阶乘是 1 ，再说明每个正整数的阶乘都是这个数与它前驱 (predecessor) 对应的阶乘的积。如下便是翻译到 Haskell 的样子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>

<p>这就是我们定义的第一个递回函数。递回在 Haskell 中十分重要，我们会在后面深入理解。如果拿一个数(如 3)呼叫 <code>factorial</code> 函数，这就是接下来的计算步骤：先计算 <code>3*factorial 2</code>，<code>factorial 2</code> 等于 <code>2*factorial 1</code>，也就是 <code>3*(2*(factorial 1))</code>。<code>factorial 1</code> 等于 <code>1*factorial 0</code>，好，得 <code>3*(2*(1*factorial 0))</code>，递回在这里到头了，嗯 — 我们在万能匹配前面有定义，0 的阶乘是 1。于是最终的结果等于 <code>3*(2*(1*1))</code>。若是把第二个模式放在前面，它就会捕获包括 0 在内的一切数字，这一来我们的计算就永远都不会停止了。这便是为什么说模式的顺序是如此重要：它总是优先匹配最符合的那个，最后才是那个万能的。</p>
<p>模式匹配也会失败。假如这个函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">charName</span> :: <span class="type">Char</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">charName</span> &#x27;a&#x27; = <span class="string">&quot;Albert&quot;</span>  </span><br><span class="line"><span class="title">charName</span> &#x27;b&#x27; = <span class="string">&quot;Broseph&quot;</span>  </span><br><span class="line"><span class="title">charName</span> &#x27;c&#x27; = <span class="string">&quot;Cecil&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>拿个它没有考虑到的字元去呼叫它，你就会看到这个：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; charName &#x27;a&#x27;  </span><br><span class="line"><span class="string">&quot;Albert&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; charName &#x27;b&#x27;  </span><br><span class="line"><span class="string">&quot;Broseph&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; charName &#x27;h&#x27;  </span><br><span class="line"><span class="string">&quot;*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName  </span></span><br></pre></td></tr></table></figure>

<p>它告诉我们说，这个模式不够全面。因此，在定义模式时，一定要留一个万能匹配的模式，这样我们的程序就不会为了不可预料的输入而崩溃了。</p>
<p><strong>使用匹配模式来展示List前几项</strong></p>
<p>弄个简单函数，让它用非标准的英语给我们展示 List 的前几项。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">tell</span> :: (<span class="type">Show</span> a) =&gt; [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">tell</span> [] = <span class="string">&quot;The list is empty&quot;</span>  </span><br><span class="line"><span class="title">tell</span> (x:[]) = <span class="string">&quot;The list has one element: &quot;</span> ++ show x  </span><br><span class="line"><span class="title">tell</span> (x:y:[]) = <span class="string">&quot;The list has two elements: &quot;</span> ++ show x ++ <span class="string">&quot; and &quot;</span> ++ show y  </span><br><span class="line"><span class="title">tell</span> (x:y:_) = <span class="string">&quot;This list is long. The first two elements are: &quot;</span> ++ show x ++ <span class="string">&quot; and &quot;</span> ++ show y  </span><br></pre></td></tr></table></figure>

<p>这个函数顾及了空 List，单元素 List，双元素 List 以及较长的 List，所以这个函数很安全。<code>(x:[])</code> 与 <code>(x:y:[])</code> 也可以写作 <code>[x]</code> 和 <code>[x,y]</code> (有了语法糖，我们不必多加括号)。不过 <code>(x:y:_)</code> 这样的模式就不行了，因为它匹配的 List 长度不固定。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/Rzd6jH"><img src="https://z3.ax1x.com/2021/07/10/Rzd6jH.png" alt="Rzd6jH.png"></a></p>
<h2 id="什么是-Guards"><a href="#什么是-Guards" class="headerlink" title="什么是 Guards"></a>什么是 Guards</h2><p>模式用来检查一个值是否合适并从中取值，而 guard 则用来检查一个值的某项属性是否为真。咋一听有点像是 <code>if</code> 语句，实际上也正是如此。不过处理多个条件分支时 guard 的可读性要高些，并且与模式匹配契合的很好。</p>
<p>在讲解它的语法前，我们先看一个用到 guard 的函数。它会依据你的 BMI 值 (body mass index，身体质量指数)来不同程度地侮辱你。BMI 值即为体重除以身高的平方。如果小于 18.5，就是太瘦；如果在 18.5 到 25 之间，就是正常；25 到 30 之间，超重；如果超过 30，肥胖。这就是那个函数(我们目前暂不为您计算 BMI，它只是直接取一个 BMI 值)。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> bmi  </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  </span><br></pre></td></tr></table></figure>



<p>guard 由跟在函数名及参数后面的竖线标志，通常他们都是靠右一个缩进排成一列。一个 guard 就是一个布尔表达式，如果为真，就使用其对应的函数体。如果为假，就送去见下一个 guard，如之继续。如果我们用 24.3 呼叫这个函数，它就会先检查它是否小于等于 18.5，显然不是，于是见下一个 guard。24.3 小于 25.0，因此通过了第二个 guard 的检查，就返回第二个字串。</p>
<p>在这里则是相当的简洁，不过不难想象这在命令式语言中又会是怎样的一棵 if-else 树。由于 if-else 的大树比较杂乱，若是出现问题会很难发现，guard 对此则十分清楚。</p>
<p>最后的那个 guard 往往都是 <code>otherwise</code>，它的定义就是简单一个 <code>otherwise = True</code> ，捕获一切。这与模式很相像，只是模式检查的是匹配，而它们检查的是布尔表达式 。如果一个函数的所有 guard 都没有通过(而且没有提供 <code>otherwise</code> 作万能匹配)，就转入下一模式。这便是 guard 与模式契合的地方。如果始终没有找到合适的 guard 或模式，就会发生一个错误。</p>
<p>当然，guard 可以在含有任意数量参数的函数中使用。省得用户在使用这函数之前每次都自己计算 <code>bmi</code>。我们修改下这个函数，让它取身高体重为我们计算。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  </span><br><span class="line">    | otherwise                 = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>    </span><br></pre></td></tr></table></figure>

<p>你可以测试自己胖不胖。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; bmiTell <span class="number">85</span> <span class="number">1.90</span>  </span><br><span class="line"><span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>运行的结果是我不太胖。不过程式却说我很丑。</p>
<p>要注意一点，函数的名字和参数的后面并没有 <code>=</code>。许多初学者会造成语法错误，就是因为在后面加上了 <code>=</code>。</p>
<h2 id="关键字-Where"><a href="#关键字-Where" class="headerlink" title="关键字 Where"></a>关键字 Where</h2><p>前一节中我们写了这个 <code>bmi</code> 计算函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  </span><br><span class="line">    | otherwise                   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>注意，我们重复了 3 次。我们重复了 3 次。程式设计师的字典里不应该有”重复”这个词。既然发现有重复，那么给它一个名字来代替这三个表达式会更好些。嗯，我们可以这样修改：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br></pre></td></tr></table></figure>

<p>我们的 <code>where</code> 关键字跟在 guard 后面(最好是与竖线缩进一致)，可以定义多个名字和函数。这些名字对每个 guard 都是可见的，这一来就避免了重复。如果我们打算换种方式计算 <code>bmi</code>，只需进行一次修改就行了。通过命名，我们提升了程式码的可读性，并且由于 <code>bmi</code> 只计算了一次，函数的执行效率也有所提升。我们可以再做下修改：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | bmi &lt;= skinny = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>  </span><br><span class="line">    | bmi &lt;= normal = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>  </span><br><span class="line">    | bmi &lt;= fat    = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>  </span><br><span class="line">    | otherwise     = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br><span class="line">          skinny = <span class="number">18.5</span>  </span><br><span class="line">          normal = <span class="number">25.0</span>  </span><br><span class="line">          fat = <span class="number">30.0</span>  </span><br></pre></td></tr></table></figure>

<p>函数在 <code>where</code> 绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间。注意，其中的名字都是一列垂直排开，如果不这样规范，Haskell 就搞不清楚它们在哪个地方了。</p>
<p><code>where</code> 绑定不会在多个模式中共享。如果你在一个函数的多个模式中重复用到同一名字，就应该把它置于全局定义之中。</p>
<p><code>where</code> 绑定也可以使用<em>模式匹配</em>！前面那段程式码可以改成：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">...  </span><br><span class="line"><span class="title">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br><span class="line">      (skinny, normal, fat) = (<span class="number">18.5</span>, <span class="number">25.0</span>, <span class="number">30.0</span>)  </span><br></pre></td></tr></table></figure>





<hr>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="Maximum"><a href="#Maximum" class="headerlink" title="Maximum"></a>Maximum</h2><p>现在看看递回的思路是如何：我们先定下一个边界条件，即处理单个元素的 List 时，回传该元素。如果该 List 的头部大于尾部的最大值，我们就可以假定较长的 List 的最大值就是它的头部。而尾部若存在比它更大的元素，它就是尾部的最大值。就这么简单！现在，我们在 Haskell 中实现它</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">maximum&#x27;</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">maximum&#x27;</span> [] = error <span class="string">&quot;maximum of empty list&quot;</span>  </span><br><span class="line"><span class="title">maximum&#x27;</span> [x] = x  </span><br><span class="line"><span class="title">maximum&#x27;</span> (x:xs)   </span><br><span class="line">    | x &gt; maxTail = x  </span><br><span class="line">    | otherwise = maxTail  </span><br><span class="line">    <span class="keyword">where</span> maxTail = maximum&#x27; xs</span><br></pre></td></tr></table></figure>

<p>如你所见，模式匹配与递回简直就是天造地设！大多数命令式语言中都没有模式匹配，于是你就得造一堆 if-else 来测试边界条件。而在这里，我们仅需要使用模式将其表示出来。第一个模式说，如果该 List 为空，崩溃！就该这样，一个空 List 的最大值能是啥？我不知道。第二个模式也表示一个边缘条件，它说， 如果这个 List 仅包含单个元素，就回传该元素的值。</p>
<p><strong>例子解析</strong></p>
<p>我们取个 List <code>[2,5,1]</code> 做例子来看看它的工作原理。当呼叫 <code>maximum&#39;</code> 处理它时，前两个模式不会被匹配，而第三个模式匹配了它并将其分为 <code>2</code> 与 <code>[5,1]</code>。 <code>where</code> 子句再取 <code>[5,1]</code> 的最大值。于是再次与第三个模式匹配，并将 <code>[5,1]</code> 分割为 <code>5</code> 和 <code>[1]</code>。继续，<code>where</code> 子句取 <code>[1]</code> 的最大值，这时终于到了边缘条件！回传 <code>1</code>。进一步，将 <code>5</code> 与 <code>[1]</code> 中的最大值做比较，易得 <code>5</code>，现在我们就得到了 <code>[5,1]</code> 的最大值。再进一步，将 <code>2</code> 与 <code>[5,1]</code> 中的最大值相比较，可得 <code>5</code> 更大，最终得 <code>5</code>。</p>
<p>改用 <code>max</code> 函数会使程式码更加清晰。如果你还记得，<code>max</code> 函数取两个值做参数并回传其中较大的值。如下便是用 <code>max</code> 函数重写的 <code>maximun&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maximum&#39; :: (Ord a) &#x3D;&gt; [a] -&gt; a  </span><br><span class="line">maximum&#39; [] &#x3D; error &quot;maximum of empty list&quot;  </span><br><span class="line">maximum&#39; [x] &#x3D; x  </span><br><span class="line">maximum&#39; (x:xs) &#x3D; max x (maximum&#39; xs)  </span><br></pre></td></tr></table></figure>

<p>太漂亮了！一个 List 的最大值就是它的首个元素与它尾部中最大值相比较所得的结果，简明扼要。</p>
<h2 id="几个递回函数"><a href="#几个递回函数" class="headerlink" title="几个递回函数"></a>几个递回函数</h2><ul>
<li><strong>replicate</strong></li>
</ul>
<p>现在我们已经了解了递回的思路,接下来就使用递回来实现几个函数. 先实现下 <code>replicate</code> 函数, 它取一个 <code>Int</code> 值和一个元素做参数, 回传一个包含多个重复元素的 List, 如 <code>replicate 3 5</code> 回传 <code>[5,5,5]</code>. 考虑一下, 我觉得它的边界条件应该是负数. 如果要 <code>replicate</code> 重复某元素零次, 那就是空 List. 负数也是同样, 不靠谱.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">replicate&#x27;</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]  </span><br><span class="line"><span class="title">replicate&#x27;</span> n x  </span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []  </span><br><span class="line">    | otherwise = x:replicate&#x27; (n<span class="number">-1</span>) x</span><br></pre></td></tr></table></figure>

<p>在这里我们使用了 guard 而非模式匹配, 是因为这里做的是布林判断. 如果 <code>n</code> 小于 0 就回传一个空 List, 否则, 回传以 <code>x</code> 作首个元素并后接重复 <code>n-1</code> 次 <code>x</code> 的 List. 最后, <code>(n-1)</code> 的那部分就会令函数抵达边缘条件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*Note*: Num 不是 Ord 的子集, 表示数字不一定得拘泥于排序, 这就是在做加减法比较时要将 Num 与 Ord 型别约束区别开来的原因.</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>take</strong></li>
</ul>
<p>接下来实现 <code>take</code> 函数, 它可以从一个 List 取出一定数量的元素. 如 <code>take 3 [5,4,3,2,1]</code>, 得 <code>[5,4,3]</code>. 若要取零或负数个的话就会得到一个空 List. 同样, 若是从一个空 List中取值, 它会得到一个空 List. 注意, 这儿有两个边界条件, 写出来:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">take&#x27;</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">take&#x27;</span> n _  </span><br><span class="line">    | n &lt;= <span class="number">0</span>   = []  </span><br><span class="line"><span class="title">take&#x27;</span> _ []     = []  </span><br><span class="line"><span class="title">take&#x27;</span> n (x:xs) = x : take&#x27; (n<span class="number">-1</span>) xs </span><br></pre></td></tr></table></figure>





<ul>
<li><strong>reverse</strong></li>
</ul>
<p><code>reverse</code> 函数简单地反转一个 List, 动脑筋想一下它的边界条件! 该怎样呢? 想想…是空 List! 空 List 的反转结果还是它自己. Okay, 接下来该怎么办? 好的, 你猜的出来. 若将一个 List 分割为头部与尾部, 那它反转的结果就是反转后的尾部与头部相连所得的 List.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">reverse&#x27;</span> :: [a] -&gt; [a]  </span><br><span class="line"><span class="title">reverse&#x27;</span> [] = []  </span><br><span class="line"><span class="title">reverse&#x27;</span> (x:xs) = reverse&#x27; xs ++ [x]  </span><br></pre></td></tr></table></figure>

<p>继续下去!</p>
<p>Haskell 支持无限 List，所以我们的递回就不必添加边界条件。这样一来，它可以对某值计算个没完, 也可以产生一个无限的资料结构，如无限 List。而无限 List 的好处就在于我们可以在任意位置将它断开.</p>
<ul>
<li><strong>repeat</strong></li>
</ul>
<p><code>repeat</code> 函数取一个元素作参数, 回传一个仅包含该元素的无限 List. 它的递回实现简单的很, 看:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">repeat&#x27;</span> :: a -&gt; [a]  </span><br><span class="line"><span class="title">repeat&#x27;</span> x = x:repeat&#x27; x  </span><br></pre></td></tr></table></figure>

<p>呼叫 <code>repeat 3</code> 会得到一个以 3 为头部并无限数量的 3 为尾部的 List, 可以说 <code>repeat 3</code> 运行起来就是 <code>3:repeat 3</code> , 然后 <code>3:3:3:3</code> 等等. 若执行 <code>repeat 3</code>, 那它的运算永远都不会停止。而 <code>take 5 (repeat 3)</code> 就可以得到 5 个 3, 与 <code>replicate 5 3</code> 差不多.</p>
<h2 id="“快速”排序"><a href="#“快速”排序" class="headerlink" title="“快速”排序"></a>“快速”排序</h2><p>假定我们有一个可排序的 List, 其中元素的型别为 Ord Typeclass 的成员. 现在我们要给它排序! 有个排序算法非常的酷, 就是快速排序 (quick sort), 睿智的排序方法. 尽管它在命令式语言中也不过 10 行, 但在 Haskell 下边要更短, 更漂亮, 俨然已经成了 Haskell 的招牌了. 嗯, 我们在这里也实现一下. 或许会显得很俗气, 因为每个人都用它来展示 Haskell 究竟有多优雅!</p>
<p>它的型别声明应为 <code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>, 没啥奇怪的. 边界条件呢? 如料，空 List。排过序的空 List 还是空 List。接下来便是算法的定义：*排过序的 List 就是令所有小于等于头部的元素在先(它们已经排过了序), 后跟大于头部的元素(它们同样已经拍过了序)*。 注意定义中有两次排序，所以就得递回两次！同时也需要注意算法定义的动词为”是”什么而非”做”这个, “做”那个, 再”做”那个…这便是函数式编程之美！如何才能从 List 中取得比头部小的那些元素呢？List Comprehension。好，动手写出这个函数！</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">quicksort</span> [] = []  </span><br><span class="line"><span class="title">quicksort</span> (x:xs) =  </span><br><span class="line">  <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] </span><br><span class="line">      biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]  </span><br><span class="line">  <span class="keyword">in</span> smallerSorted ++ [x] ++ biggerSorted  </span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; quicksort [<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; quicksort <span class="string">&quot;the quick brown fox jumps over the lazy dog&quot;</span>  </span><br><span class="line"><span class="string">&quot; abcdeeefghhijklmnoooopqrrsttuuvwxyz&quot;</span>  </span><br></pre></td></tr></table></figure>





<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ul>
<li>1</li>
</ul>
<p>This task is meant to be solved with list comprehension.</p>
<p>Write a function headOrLast :: [String] -&gt; Char -&gt; [String] that, given a list of strings and a character, evaluates to a list with all the strings of the input list that either begin or end with the input character.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">headOrLast</span> :: [<span class="type">String</span>] -&gt; <span class="type">Char</span> -&gt; [<span class="type">String</span>]</span><br><span class="line"><span class="comment">-- use the function &quot;last&quot; and &quot;head&quot; to provide the propriate condition</span></span><br><span class="line"><span class="title">headOrLast</span>  a b = [a |  a&lt;-a ,head a==b ||last a==b]</span><br></pre></td></tr></table></figure>







<ul>
<li>2</li>
</ul>
<p>This task is meant to be solved with guards.</p>
<p>We represent playing cards with (Char, Int) pairs. ‘s’ means spades, ‘h’ hearts, ‘c’ clubs’ and ‘d’ diamonds, with number values going from 2 to 14 (Ace being 14). Consider a game, where a player is dealt two cards and wins credits based on the following rules:</p>
<p>If the player has the Ace of Spades (‘s’, 14), then the player wins 6 credits.<br>Otherwise if the player has a pair (same number values), then the player wins 4 credits.<br>Otherwise if the player has two cards of the same suit, then the player wins 2 credits.<br>Otherwise, the player wins 0 credits.</p>
<p>Write a function credits :: (Char, Int) -&gt; (Char, Int) -&gt; Int that evaluates the given credits.</p>
<p>You can assume that the given cards are real</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">credits</span> :: (<span class="type">Char</span>, <span class="type">Int</span>) -&gt; (<span class="type">Char</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">-- the first card is (&#x27;s&#x27;,14)</span></span><br><span class="line"><span class="title">credits</span> (&#x27;s&#x27;,<span class="number">14</span>) (c,d) = <span class="number">6</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment">-- the second card is (&#x27;s&#x27;,14)</span></span><br><span class="line"><span class="title">credits</span> (a,b) (&#x27;s&#x27;,<span class="number">14</span>) = <span class="number">6</span></span><br><span class="line"><span class="comment">--caculate credit(the cards not include spades A)</span></span><br><span class="line"><span class="title">credits</span> (a,b) (c,d)</span><br><span class="line"> | b==d = <span class="number">4</span></span><br><span class="line"> | a==c = <span class="number">2</span></span><br><span class="line"> | otherwise = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>3</li>
</ul>
<p>This task is meant to be solved with recursion.</p>
<p>Write a function nextIsGreater :: [Int] -&gt; [Int] that, given a list of numbers, produces a list with all elements of the input list such that the element is followed by a greater number in the input list (the next number is greater).</p>
<p>The numbers need to be in the same order relative to each other in the output list as they are in the input list.</p>
<p>An example evaluation of the function:</p>
<p>function call:<br>nextIsGreater [0,5,2,3,2,2,3,1]<br>result:<br>[0,2,2]</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">nextIsGreater</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">nextIsGreater</span> [] = []</span><br><span class="line"><span class="title">nextIsGreater</span> [x] = []</span><br><span class="line"><span class="title">nextIsGreater</span> (x:xs) </span><br><span class="line"> | x &lt; head xs = x:nextIsGreater xs</span><br><span class="line"> |otherwise = nextIsGreater xs</span><br></pre></td></tr></table></figure>







<ul>
<li>4</li>
</ul>
<p>This task is suitable for a recursive solution.</p>
<p>We say that character pair (c1,c2) appears in string s with gap g, if c1 is before c2 and there are exactly g characters between c1 and c2 in s.</p>
<p>Write a function gap :: (Char, Char) -&gt; Int -&gt; String -&gt; Int that, given a pair (c1,c2), a gap g and a string s returns an Int telling how many times (c1,c2) appear in s with gap g.</p>
<p>For example:</p>
<p>function call:<br>gap (‘a’,’b’) 1 “aaabbb”<br>result:<br>2</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="title">gap</span> :: (<span class="type">Char</span>, <span class="type">Char</span>) -&gt; <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">gap</span> (a,b) c  <span class="string">&quot;&quot;</span>= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">gap</span> (a,b) c (x:xs) </span><br><span class="line"> | length xs&gt; c&amp;&amp; x == last (take (c+<span class="number">1</span>) xs) = <span class="number">1</span> + gap (a,b) c xs</span><br><span class="line"> |otherwise = <span class="number">0</span> + gap (a,b) c xs</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>5</li>
</ul>
<p>Notice that e.g. length of a list is an Int and you can get a fractional (non-Integer) value out of that with the fromIntegral function.</p>
<p>Write a function distance1 :: String -&gt; String -&gt; Float that, given two strings s1 and s2, calculates their distance using the following formula ( (count of how many of the characters in s1 do not appear in s2 + (count of how many of the characters in s2 do not appear in s1) ) / ( (length of s1) + (length of s2) ). If both of the lists are empty, then the distance is 0.</p>
<p>For example, the distance between “aaabc” and “aabdd” with this function is (1 + 2) / (5 + 5).</p>
<p>Please note that this function is not standard well-behaving distance functions.</p>
<p>Hint: List comprehension is useful here.</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--5</span></span><br><span class="line"><span class="title">distance1</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">distance1</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;&quot;</span> = <span class="number">0</span></span><br><span class="line"><span class="title">distance1</span> s1 s2 = fromIntegral(length [x | x &lt;- s1,not(x `elem` s2)] + length [x | x &lt;- s2,not(x `elem` s1)]) / fromIntegral(length s1 + length s2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<ul>
<li>6</li>
</ul>
<p>Write a function clusters that is given:</p>
<ul>
<li>f,   a distance function of type String -&gt; String -&gt; Float (like the one in the previous Task 5)</li>
<li>d :: Float</li>
<li>ss :: [String]<br>For each string s  in ss, the function clusters computes a “cluster”, ie a list of similar strings in ss (strings that are at most distance d from the s). The list of strings similar to s should also contain s (if the distance function allows). </li>
</ul>
<p>The clusters and the list of clusters may be in any order. </p>
<p>Calling this function with function of Task 5, d=0.3 and ss=[“aaabc”, “aabdd”, “a”, “aa”, “abdd”, “bcbcb”, “”, “abcdefghij”]<br>should return<br>[[“”],[“a”,”aa”],[“a”,”aa”,”aaabc”],[“aa”,”aaabc”,”aabdd”,”bcbcb”],[“aaabc”,”aabdd”,”abdd”],[“aaabc”,”bcbcb”],[“aabdd”,”abdd”],[“abcdefghij”]]</p>
<p>(in some order).</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--6</span></span><br><span class="line"><span class="title">cluster</span> :: (<span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Float</span>) -&gt; <span class="type">Float</span> -&gt; [<span class="type">String</span>] -&gt;[[<span class="type">String</span>]]</span><br><span class="line"><span class="title">cluster</span> _ _ [] = []</span><br><span class="line"><span class="title">cluster</span> f d ss = [filter f&#x27; ss | s &lt;- ss,<span class="keyword">let</span> f&#x27; x = (f s x) &lt;= d ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>







</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Steven林</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://steven900516.gitee.io/2021/07/09/Haskell%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/">https://steven900516.gitee.io/2021/07/09/Haskell%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://steven900516.gitee.io" target="_blank">萌新杀手的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Haskell/">Haskell</a></div><div class="post_share"><div class="social-share" data-image="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3093977134,1475813689&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/14/LeetCode/"><img class="prev-cover" src="https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/8b82b9014a90f6030add233a3b12b31bb051ed5a.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LeetCode</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/10/Springboot%E5%92%8CEcharts%E4%BD%BF%E7%94%A8/"><img class="next-cover" src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3302399998,3216746631&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Springboot和Echarts使用</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://imgtu.com/i/fPBsaR" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Steven林</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/steven900516" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BD%BF%E7%94%A8-t%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B-%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">各种类型（使用:t进行查看 ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Haskell%E8%87%AA%E5%B8%A6%E5%87%BD%E6%95%B0%E5%9E%8B%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">Haskell自带函数型别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">函数语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-Pattern-matching"><span class="toc-number">3.1.</span> <span class="toc-text">模式匹配 (Pattern matching)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Guards"><span class="toc-number">3.2.</span> <span class="toc-text">什么是 Guards</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-Where"><span class="toc-number">3.3.</span> <span class="toc-text">关键字 Where</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximum"><span class="toc-number">4.1.</span> <span class="toc-text">Maximum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E9%80%92%E5%9B%9E%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">几个递回函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E5%BF%AB%E9%80%9F%E2%80%9D%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">“快速”排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">练习题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="缓存击穿，缓存穿透，缓存雪崩"><img src="https://pic4.zhimg.com/v2-af1fefc4f2f5b99b79787b57756e6ea4_r.jpg?source=1940ef5c" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存击穿，缓存穿透，缓存雪崩"/></a><div class="content"><a class="title" href="/2021/12/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" title="缓存击穿，缓存穿透，缓存雪崩">缓存击穿，缓存穿透，缓存雪崩</a><time datetime="2021-12-12T13:37:47.000Z" title="发表于 2021-12-12 21:37:47">2021-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/ConcurrentHashMap/" title="ConcurrentHashMap"><img src="https://pic1.zhimg.com/v2-60d534560cc52564f74c6e37e302227a_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ConcurrentHashMap"/></a><div class="content"><a class="title" href="/2021/12/01/ConcurrentHashMap/" title="ConcurrentHashMap">ConcurrentHashMap</a><time datetime="2021-12-01T02:24:47.000Z" title="发表于 2021-12-01 10:24:47">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/" title="类加载完整流程"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="类加载完整流程"/></a><div class="content"><a class="title" href="/2021/11/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B/" title="类加载完整流程">类加载完整流程</a><time datetime="2021-11-26T03:04:27.000Z" title="发表于 2021-11-26 11:04:27">2021-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/ThreadPoolExecutor/" title="ThreadPoolExecutor"><img src="https://ts1.cn.mm.bing.net/th?id=OIP-C.q6QaR2zyDxrl_OSMcxhv9gHaEo&amp;w=176&amp;h=170&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ThreadPoolExecutor"/></a><div class="content"><a class="title" href="/2021/11/17/ThreadPoolExecutor/" title="ThreadPoolExecutor">ThreadPoolExecutor</a><time datetime="2021-11-17T08:27:47.000Z" title="发表于 2021-11-17 16:27:47">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/17/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="InnoDB存储引擎"><img src="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ocvbbp6zFOcaFwGTv9b6eQHaGe&amp;w=176&amp;h=170&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;pid=3.1&amp;rm=2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="InnoDB存储引擎"/></a><div class="content"><a class="title" href="/2021/11/17/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="InnoDB存储引擎">InnoDB存储引擎</a><time datetime="2021-11-17T07:11:06.000Z" title="发表于 2021-11-17 15:11:06">2021-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Steven林</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>